## MVC

### Model

- 데이터 + 상태 + 비즈니스 로직



### View

- 모델의 표현

UI를 그리고 사용자가 앱과 상호작용할 때 컨트롤러와 통신한다.

모델에 대해 전혀 알지 못해 모델에 종속되지 않아 변화에 유연하다.



### Controller

- 모델과 뷰 사이의 중간자

뷰가 컨트롤러에게 사용자와의 상호작용을 알리면, 컨트롤러는 그에 따라 모델과 어떻게 상호작용할지 결정한다.

그리고 모델에서 데이터가 변화함에 따라 컨트롤러는 뷰의 상태를 업데이트한다.

보통 액티비티나 프래그먼트가 컨트롤러가 된다.



![Screen Shot 2019-04-08 at 11.44.22 AM](/Users/minjyo/Desktop/Screen Shot 2019-04-08 at 11.44.22 AM.png)



### 장점

모델과 뷰를 잘 분리해준다. 모델이 어디에도 종속되지 않으며, 뷰는 유닛 테스트 레벨에서 테스트할 것이 거의 없어서 쉽게 모델을 테스트할 수 있다.



### 단점

- 테스트 용이성

컨트롤러가 안드로이드 API에 깊게 종속되어 있어, 유닛 테스트가 어렵다.

- 모듈화 및 유연성

컨트롤러가 뷰의 확장이라고도 볼 수 있어, 뷰를 변경하면 컨트롤러에서도 변경해야 한다.

- 유지 보수

개발을 할수록 컨트롤러에 많은 코드가 쓰이면서 컨트롤러가 점점 커지게 된다. 









## MVP

### Model

MVC와 동일



### View

액티비티와 프래그먼트도 뷰가 되어서, 서로에게 연관되지 않는다.

액티비티가 뷰 인터페이스를 구현해서 구현해서 프리젠터가 코드를 만들 인터페이스를 갖도록 하면,

특정 뷰와 결합되지 않고 가상 뷰를 구현해서 간단한 유닛 테스트를 실행할 수 있다.



### Presenter

컨트롤러와의 본질은 같지만, 컨트롤러처럼 뷰에 연결되는 것이 아니라 인터페이스이다. 

뷰에게 무언가를 표시하는 방법을 지시하는 대신, 표시할 내용만 전달한다.



![Screen Shot 2019-04-09 at 5.22.54 PM](/Users/minjyo/Desktop/Screen Shot 2019-04-09 at 5.22.54 PM.png)



### 장점

안드로이드 고유의 뷰와 API에 연결되지 않으므로 뷰 인터페이스를 구현했다면 어떤 뷰와도 작업할 수 있어서 

프리젠터 로직을 쉽게 테스트할 수 있다.



### 단점

- 유지보수 

컨트롤러처럼 프리젠터에도 시간이 지남에 따라 추가 비즈니스 로직이 모이는 경향이 있다.

마찬가지로 문제가 발생하기 쉽고 분리하기도 어려워진다.







## MVVM

### Model

MVC와 동일



### View

뷰모델에 의해 보여지는 Observable 변수와 액션에 바인딩된다.



### ViewModel

뷰모델은 모델을 래핑하고 뷰에 필요한 Observable 데이터를 준비한다.

뷰가 모델에 이벤트를 전달할 수 있도록 hook을 준비한다. 

뷰에 종속되지는 않는다.



![Screen Shot 2019-04-09 at 5.28.09 PM](/Users/minjyo/Desktop/Screen Shot 2019-04-09 at 5.28.09 PM.png)



### 장점

뷰에 대한 의존성이 전혀 없어서 유닛 테스트가 더 쉬워진다. MVP 패턴처럼 테스트를 위한 가상 뷰를 만들 필요 없이, 테스트할 때 모델이 변경되는 시점에 Observable 변수가 제대로 설정됐는지 확인하면 된다.

뷰와 모델을 연결하기 위해 사용해야 하는 연결 코드를 줄일 수 있다.



### 단점

- 유지관리

뷰가 변수와 표현식 모두에 바인딩될 수 있어서 시간이 지남에 따라 관계없는 프리젠테이션 로직이 늘어나 XML에 코드를 추가하게 될 수 있다. 이를 방지하려면 뷰 바인딩 표현식에서 값을 계산하거나 파생하지 말고 항상 뷰모델에서 직접 값을 가져오는 것이 좋다. 이 방식으로 한 계산을 유닛 테스트할 수 있다.